import { POINTER_REGEXP, pointerTrim } from "./utils.js";

/**
 * Processing context exposed to rule invocations as their `this`.
 */
export default class ProcContext {
  constructor({ parseDriver, parseProgress }) {
    // Ideally this wouldn't be exposed, but Obj.expect wants to use its parse()
    // method.
    this._parseDriver = parseDriver;
    this.parseProgress = parseProgress;

    this.global = {};
    this.captureid = 0;
    this._captures = [];
    this._sync = {};

    // XXX Legacy-ish: Previously, this value would be set based on whether
    // e10s was implied by the existence of distinct parent and child logs as
    // generated by about:networking's logging tab, but this does not hold true
    // under various unified log situations, so as those gathered from the
    // command line by build and test tools.  Also, it assumes a Necko world
    // where IPC is only used for e10s, but things like IndexedDB use IPC in
    // all cases, the marshaling is just more optimized in a single process.
    //
    // So currently this is always set to true.
    this._ipc = true;

    /**
     * Dictionary containing currently alive Obj instances.  Keys are either
     * pointers represented as normalized lowercase hexadecimal strings, or
     * possibly arbitrary non-pointer aliases.  Usually aliases will be pointers
     * to the same underlying object (due to C++ object slicing) or helper
     * classes that don't merit their own independent Obj tracking.
     *
     * When new keys/aliases are added, _update_alias_regexp is used to update
     * the derived `nonPtrAliases` regexp that is supposed to be able to match
     * all pointer-ish things.
     */
    this.objs = {};
    /**
     * The list of all Obj instances ever created during parsing.
     *
     * (Originally stored on the logan namespace.)
     */
    this.objects = [];

    /**
     * If there are any keys in `objs` which don't match `POINTER_REGEXP`, this
     * is a RegExp instance that will match any of those aliases, returning it
     * in the first capture group.  If there are no such aliases, this is null.
     */
    this.nonPtrAliases = null;

    this.searchProps = [];
  }

  /**
   * Update the `nonPtrAliases` regexp that will match and capture any of the
   * keys in `objs` that do not match `POINTER_REGEXP`.
   */
  _update_alias_regexp() {
    let nonPtrAliases = [];
    for (let obj of Object.keys(this.objs)) {
      if (!obj.match(POINTER_REGEXP)) {
        nonPtrAliases.push(escapeRegexp(obj));
      }
    }
    this.nonPtrAliases = nonPtrAliases.length === 0 ? null : new RegExp("(" + nonPtrAliases.join("|") + ")", "g");
  };

  _obj(ptr, store) {
    if (Obj.prototype.isPrototypeOf(ptr)) {
      return ptr;
    }

    ptr = pointerTrim(ptr);
    if (ptr === "0") {
      store = false;
    }

    let obj = this.objs[ptr];
    if (!obj) {
      obj = new Obj(this, ptr);
      this.objects.push(obj);
      if (store) {
        this.objs[ptr] = obj;
        if (!ptr.match(POINTER_REGEXP)) {
          this._update_alias_regexp();
        }
      }
    }

    obj.__most_recent_accessor = ptr;
    return obj;
  }

  _forgetObj(obj) {
    delete this.objs[obj.props.pointer];
    let updateAliasRegExp = false;
    for (let alias in obj.aliases) {
      if (!alias.match(POINTER_REGEXP)) {
        updateAliasRegExp = true;
      }
      delete this.objs[alias];
    }

    if (updateAliasRegExp) {
      this._update_alias_regexp();
    }
  }

  objIf(ptr) {
    return this._obj(ptr, false);
  }

  obj(ptr) {
    return this._obj(ptr, true);
  }

  duration(timestamp) {
    if (!timestamp) {
      return undefined;
    }
    return this.timestamp.getTime() - timestamp.getTime();
  }

  // private
  save() {
    return ["timestamp", "thread", "line", "file", "module", "raw", "binaryoffset"].reduce(
      (result, prop) => (result[prop] = this[prop], result), {});
  }

  restore(from) {
    for (let property in from) {
      this[property] = from[property];
    }
  }

  swap(through) {
    let result = this.save();
    this.restore(through);
    return result;
  }
};
